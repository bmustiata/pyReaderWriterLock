#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
This is a script to build the project.

It is using template_BUILDME_python3 v6.

This script:
	- Should be named "BUILDME"
	- Should be present in the project root folder
	- Should be executable (chmod +x BUILDME)
	- Should contains all the project build process steps implemented into the function BUILDME (see below)
"""

from typing import Optional
from typing import Sequence
import argparse
import os
import shutil
import subprocess
import sys
import tempfile


def buildme(s: str, t: str, o: str) -> int:
	"""
	Build the project.

	@param s The project root folder, the build steps shall only access this folder in read only mode
	@param t A folder where the build steps are free to write temporary file/folder
	@param o A folder where the build result should be written to
	@returns Exit code 0 on success or raise an Exception if something failed
	"""

	v_exit_code = 0

	# Fetch the project name.
	with open(os.path.join(s, "NAME"), "r") as c_file_handle:
		s_name = c_file_handle.read().strip()

	# Running unit test
	assert sys.executable is not None
	assert 0 < len(sys.executable)

	for c_curr_destination in [t, o]:
		# Create output directories.
		os.makedirs(os.path.join(c_curr_destination, s_name))
		os.makedirs(os.path.join(c_curr_destination, "tests"))
		# Copy the files
		shutil.copy(os.path.join(s, s_name, "__init__.py"), os.path.join(c_curr_destination, s_name))
		shutil.copy(os.path.join(s, s_name, "rwlock.py"), os.path.join(c_curr_destination, s_name))
		shutil.copy(os.path.join(s, s_name, "py.typed"), os.path.join(c_curr_destination, s_name))
		shutil.copy(os.path.join(s, "tests", "rwlock_test.py"), os.path.join(c_curr_destination, "tests"))
		if t == c_curr_destination:
			# Prepare environment variables
			my_env = os.environ.copy()
			try:
				my_env["PYTHONPATH"] = c_curr_destination + ":" + my_env["PYTHONPATH"]
			except KeyError:
				my_env["PYTHONPATH"] = c_curr_destination
			if True:  # Lint
				if True:  # StaticCode analysis: mypy
					if 0 != subprocess.call([sys.executable, "-m", "mypy", "--config-file", os.path.join(s, "setup.cfg"), "-p", s_name], universal_newlines=True, cwd=t, env=my_env):
						v_exit_code = 1
					if 0 != subprocess.call([sys.executable, "-m", "mypy", "--config-file", os.path.join(s, "setup.cfg"), os.path.join(c_curr_destination, "tests", "rwlock_test.py")], universal_newlines=True, cwd=t, env=my_env):
						v_exit_code = 1
				if True:  # Coding standard: pylint
					if 0 != subprocess.call([sys.executable, "-m", "pylint", "--persistent", "n", "--rcfile", os.path.join(s, "setup.cfg"), s_name], universal_newlines=True, cwd=t, env=my_env):
						v_exit_code = 1
				if True:  # Coding standard: flake8
					for c_curr_folder in [s_name, "tests"]:
						if 0 != subprocess.call([sys.executable, "-m", "flake8", "--show-source", "--config=" + os.path.join(s, "setup.cfg"), c_curr_folder], universal_newlines=True, cwd=t, env=my_env):
							v_exit_code = 1
				if True:  # Documentation standard: pydocstyle
					for c_curr_folder in [s_name, "tests"]:
						if 0 != subprocess.call([sys.executable, "-m", "pydocstyle", "--explain", "--source", c_curr_folder, "--config", os.path.join(s, "setup.cfg")], universal_newlines=True, cwd=t, env=my_env):
							v_exit_code = 1
			if True:  # Run unit tests
				if 0 != subprocess.call([sys.executable, os.path.join(t, "tests", "rwlock_test.py")], universal_newlines=True, cwd=t, env=my_env):
					v_exit_code = 1
	return v_exit_code

########################################################
########################################################
# ###########################
# ########################### Copy this template build executable to your own project root folder
# ########################### Anything above this line is considered part of your project
# ########################### Anything below this line is part of the BUILDME project <https://github.com/elarivie/BUILDME> and is licensed under GPLv3
# ########################### Note: You don't have to edit anything below this line, if you have to, please fill an issue at https://github.com/elarivie/BUILDME
# ###########################
########################################################
########################################################


def main(p_args: Sequence[str]) -> int:
	"""Main."""
	parser = argparse.ArgumentParser(description="Build the project", epilog="""
Exit code 0 if build is successfull
""")
	parser.add_argument("-s", help="source folder (Default: Current working directory)", action="store", default=os.getcwd())
	parser.add_argument("-t", help="temporary folder (Default: new temporary directory in the system temporary directory or RAM temp folder if available)", action="store", default=None)
	parser.add_argument("-o", help="output folder, shall not already exist (Default: new temporary directory in TEMPFOLDER)", action="store", default=None)
	parser.add_argument("-V", "--version", action="version", version="BUILDME 2.0.0")
	c_args = parser.parse_args(p_args)

	def _actualpath(p_path: Optional[str]) -> Optional[str]:
		return None if p_path is None else os.path.normcase(os.path.realpath(os.path.normpath(p_path)))

	c_path = [_actualpath(x) for x in [c_args.s, c_args.t, c_args.o]]

	if c_path[1] is None:
		try:
			# Use RAM temp folder if available
			c_path[1] = os.path.abspath(os.path.join(os.sep, "run", "user", str(os.getuid())))
			assert c_path[1] is not None
			if not os.path.isdir(c_path[1]):
				c_path[1] = None
		except AttributeError:
			pass  # os.getuid() is only available on Unix (it is the only os which might have a ram temp folder anyway)
	v_build_result = None
	c_orig_cwd = os.getcwd()
	v_tmp_path = None
	v_build_error = True
	try:
		with tempfile.TemporaryDirectory(suffix="", prefix="", dir=c_path[1]) as c_tmp_folder:
			v_tmp_path = _actualpath(c_tmp_folder)
			assert v_tmp_path is not None
			try:
				c_path[1] = None
				for i in [0, 1, 2]:
					if c_path[i] is None:
						c_path[i] = _actualpath(tempfile.mkdtemp(suffix="", prefix="", dir=v_tmp_path))
				assert c_path[1] is not None

				os.chdir(c_path[1])  # Make sure that the current working directory is the Temp folder before doing the build steps
				v_build_result = buildme(*c_path)
				# From this point, the only thing left to do is to delete the temp folder
				v_build_error = False
			finally:
				os.chdir(c_orig_cwd)  # Get out of the temp folder since it is about to be deleted
	except BaseException:
		if v_build_error: raise
		# Problem cleaning temp folder... will be handled in the finally block
	finally:
		assert v_tmp_path is not None
		assert not os.path.exists(v_tmp_path), "Temp folder could not be cleaned: " + str(v_tmp_path)
		assert v_build_result is not None
	return v_build_result


if "__main__" == __name__:
	sys.dont_write_bytecode = True
	sys.exit(main(sys.argv[1:]))
